
# coding: utf-8

# In[ ]:

# Event types:

# Tick - Generated by Data Handler and added to queue

# Signal - Generated by strategy module. Fed through to portfolio module which calls risk.

# Order - Generated by portfolio & handled by execution module

# Fill - Generated by execution module & handled by portfolio


# In[1]:

from datetime import datetime
import collections


# In[2]:

class event:
    
    def __init__(self, event_type):
        self.type = event_type
        self.time = datetime.utcnow()
        


# In[3]:

class event_queue:
    
    def __init__(self):
        self.queue = collections.deque()
        
    def add_to_queue(self, event):
        self.queue.append(event)
    
    def handle_next(self):
        if self.queue:
            event = self.queue.popleft()
            if event = None:
                pass
            elif event.type == 'tick':
                #Call strategy
                print('Tick Event Popped')
            elif event.type == 'signal':
                #Call risk
                print('Signal Event Popped')
            elif event.type == 'order':
                #Call portfolio
                print('Order Event Popped')
            elif event.type == 'fill':
                #Call Execute
                print('Fill Event Popped')
        else:
            print('Queue is empty')
            
        
        


# In[4]:

# Test classes -------------------------------------

# Create event objects
tick = event('tick')
signal = event('signal')
order = event('order')
fill = event('fill')

# Create event_queue object and add above objects to queue
eq = event_queue()
eq.add_to_queue(tick)
eq.add_to_queue(order)
eq.add_to_queue(signal)
eq.add_to_queue(fill)

# Call handle_next function on queue object - pops event objects in FIFO order
eq.handle_next()
eq.handle_next()
eq.handle_next()
eq.handle_next()
eq.handle_next()


# In[ ]:



